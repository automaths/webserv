#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <math.h>

# define E_MONSTER 0
# define E_MY_HERO 1
# define E_OP_HERO 2

typedef struct s_entity
{
    int 	id;
    int 	type;
    int 	x;
    int 	y;
    int 	shield_life;
    int 	is_controlled;
    int 	health;
    int 	vx;
    int 	vy;
    int 	near_base;
    int 	threat_for;
    int     reach_base_in;
}   t_entity;

typedef struct s_specs
{
    int         x;
    int         y;
    int         health;
    int         mana;
    int         heroes;
    int         entity_count;
    int         nb_monsters;
    t_entity    my_heroes[3];
    t_entity    enemy_heroes[3];
    t_entity    entities[2000];
    t_entity    enemies[2000];
}   t_specs;
/*
int dbg_print_entity(s_entity *e) {
    fprintf(stderr, "================\n");
    switch (e->type) {
        case ENTITY_TYPE_MY_HERO: fprintf(stderr, "My hero %d:\n", e->id); break;
        case ENTITY_TYPE_OP_HERO: fprintf(stderr, "Op hero %d:\n", e->id); break;
        case ENTITY_TYPE_MONSTER: fprintf(stderr, "Monster %d:\n", e->id); break;
        default : fprintf(stderr, "print error: undefined entity type: %d\n", e->type);
    }
    fprintf(stderr, "x: %d   y: %d\n", e->x, e->y);
    fprintf(stderr, "shield_life: %d\n", e->shield_life);
    fprintf(stderr, "is_controlled: %d\n", e->is_controlled);
    fprintf(stderr, "health: %d\n", e->health);
    fprintf(stderr, "vx: %d   vy: %d\n", e->vx, e->vy);
    fprintf(stderr, "near_base: %d\n", e->near_base);
    fprintf(stderr, "threat_for: %d\n", e->threat_for);
    fprintf(stderr, "================\n\n");
    return (1);
}*/

void    determine_enemies(t_specs *my_specs, t_specs enemy_specs)
{

}

void    get_enemy_base_location(t_specs my_specs, t_specs *enemy_specs)
{
    if (my_specs.x == 0)
        enemy_specs->x = 17630;
    else
}
int main()
{
    int     nb_my_heroes;
    int     nb_enemy_heroes;
    t_specs my_specs;
    t_specs enemy_specs;

    // Base coordinates
    scanf("%d%d", &my_specs.x, &my_specs.y);
    get_enemy_base_location(my_specs, &enemy_specs);
    // Heroes per player
    int heroes_per_player;
    scanf("%d", &heroes_per_player);
    
/*    my_specs.entities = (t_entity *)calloc(2001, sizeof(t_entity));
    if (!my_specs.entities)
        exit (1);*/
    // game loop
    while (1) {
        scanf("%d%d", &my_specs.health, &my_specs.mana);
        scanf("%d%d", &enemy_specs.health, &enemy_specs.mana);
        scanf("%d", &my_specs.entity_count);
        fprintf(stderr, "My health: %d, my mana:%d\n", my_specs.health, my_specs.mana);
        fprintf(stderr, "Enemy health: %d, enemy mana:%d\n", enemy_specs.health, enemy_specs.mana);
        my_specs.nb_monsters = 0;
        nb_my_heroes = 0;
        nb_enemy_heroes = 0;
        for (int i = 0; i < my_specs.entity_count; i++) {
            //id: Unique identifier
            //type: 0=monster, 1=your hero, 2=opponent hero
            //x: Position of this entity
            //shieldLife: Ignore for this league; Count down until shield spell fades
            //isControlled: Ignore for this league; Equals 1 when this entity is under a control spell
            //health: Remaining health of this monster
            //vx: Trajectory of this monster
            //nearBase: 0=monster with no target yet, 1=monster targeting a base
            //threatFor: Given this monster's trajectory, is it a threat to 1=your base, 2=your opponent's base, 0=neither
            scanf("%d%d%d%d%d%d%d%d%d%d%d",
                &(my_specs.entities[my_specs.nb_monsters].id), &(my_specs.entities[my_specs.nb_monsters].type), \
                &(my_specs.entities[my_specs.nb_monsters].x), &(my_specs.entities[my_specs.nb_monsters].y), \
                &(my_specs.entities[my_specs.nb_monsters].shield_life), &(my_specs.entities[my_specs.nb_monsters].is_controlled), \
                &(my_specs.entities[my_specs.nb_monsters].health), &(my_specs.entities[my_specs.nb_monsters].vx), \
                &(my_specs.entities[my_specs.nb_monsters].vy), &(my_specs.entities[my_specs.nb_monsters].near_base), \
                &(my_specs.entities[my_specs.nb_monsters].threat_for));
            if (my_specs.entities[my_specs.nb_monsters].type == E_MONSTER)
                my_specs.nb_monsters += 1;
            else if (my_specs.entities[my_specs.nb_monsters].type == E_MY_HERO)
            {
                my_specs.my_heroes[nb_my_heroes] = my_specs.entities[my_specs.nb_monsters];
                nb_my_heroes++; 
            }
            else
            {
                my_specs.enemy_heroes[nb_enemy_heroes] = my_specs.entities[my_specs.nb_monsters];
                nb_enemy_heroes++;
            }
        }
        my_specs.entities[my_specs.nb_monsters].type = -1;
        determine_enemies(&my_specs);
        for (int i = 0; i < 3; i++)
            write(1, "WAIT\n", 5);
    }
 //   free(my_specs.entities);
    return (0);
}